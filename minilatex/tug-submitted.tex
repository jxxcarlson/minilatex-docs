
\documentclass[11pt, oneside]{article}

%% Packages
\usepackage{amssymb} %% NO
\usepackage{amsmath}
\usepackage{amscdx}  % instead of amscd
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=blue,
}
\usepackage{xcolor}
\usepackage{soul}


%% Commands
\newcommand{\code}[1]{{\tt #1}}
\newcommand{\ellie}[1]{\href{#1}{Link to Ellie}}
% \newcommand{\image}[3]{\includegraphics[width=3cm]{#1}}

\newcommand{\imagecenter}[3]{{
   \medskip
   \begin{figure}
   \centering
    \includegraphics[width=12cm,height=12cm,keepaspectratio]{#1}
    \vglue0pt \par {#2}
    \end{figure}
    \medskip
}}

\newcommand{\imagefloatright}[3]{
    \begin{wrapfigure}{R}{0.30\textwidth}
    \includegraphics[width=0.30\textwidth]{#1}
    \caption{#2}
    \end{wrapfigure}
}

\newcommand{\imagefloatleft}[3]{
    \begin{wrapfigure}{L}{0.3-\textwidth}
    \includegraphics[width=0.30\textwidth]{#1}
    \caption{#2}
    \end{wrapfigure}
}

\newcommand{\italic}[1]{{\sl #1}}
\newcommand{\strong}[1]{{\bf #1}}
\newcommand{\subheading}[1]{{\bf #1}\par}
\newcommand{\xlinkPublic}[2]{\href{{http://www.knode.io/\#@public#1}}{#2}}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\remote}[1]{\textcolor{red}{#1}}
\newcommand{\local}[1]{\textcolor{blue}{#1}}
\newcommand{\highlight}[1]{\hl{#1}}
\newcommand{\editnote}[2]{{\textcolor{blue}{#1}: }{\hl{#1}}}
\newcommand{\strike}[1]{\st{#1}}
\newcommand{\term}[1]{{\sl #1}}
\newtheorem{remark}{Remark}
\newcommand{\comment}[1]{}
\newcommand{\innertableofcontents}{}
\newcommand{\xlink}[2]{}

%% Theorems
\newtheorem{theorem}{Theorem}
\newtheorem{axiom}{Axiom}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{exercise}{Exercise}
\newtheorem{problem}{Problem}
\newtheorem{exercises}{Exercises}
\newcommand{\bs}[1]{$\backslash$#1}
\newcommand{\texarg}[1]{\{#1\}}

%% Environments
\renewenvironment{quotation}
  {\begin{adjustwidth}{2cm}{} \footnotesize}
  {\end{adjustwidth}}

% Spacing
\parindent0pt
\parskip5pt

\begin{document}




 \title{MiniLaTeX:  a  subset  of  LaTeX  for  the  Web}  \author{James  Carlson}  \date{August  8,  2020}
 \maketitle
\parskip0pt
\tableofcontents
\parskip5pt
 \href{https://youtu.be/TAIYpCc3VV0}{Video  version  of  this  paper}


\italic{MiniLateX  is  a  no-setup  subset  of  LaTeX  that  can  be  rendered  on  the  fly  to  HTML.    One  can  use  it  to  build  web  apps  with  true  HTML  display  viewable  on  any  device  from  smart  phone  to  tablet  to  desktop.   Typesetting  occurs  in  real  time,  and  error  messages  are  displayed  in-line  in  the  rendered  text.  MiniLaTeX  documents  can  be  exported  to  standard  LaTeX.

  \medskip We  describe  (a)  MiniLaTeX  the  language,  (b)  the  main  features  of  the  the  document  management  application
  \href{https://minilatex.lamdera.app}{minilatex.lamdera.app},  and  (c)  some  of  the  technical  work  required  to  implement  an  on-the-fly  LaTeX-to-Html  compiler.}




 \section{Introduction}
MiniLaTeX  is  a  no-setup  subset  of  LaTeX  that  comes  with  an  on-the-fly  compiler  to  HTML:


\begin{itemize}
\item  \strong{No  setup.} Just  begin  typing.   No  preamble  with   \code{ \bs{usepackage}} statements,   \code{ \bs{begin}\texarg{document}},  etc.,  is  needed.




 \item  \strong{On-the-fly.} A  typical  editor  for  MiniLaTeX  presents  two  windows.   On  the  left  is  the  source  text,  on  the  right  is  the  rendered  text.   Changes  to  the  source  text  are  immediately  reflected  in  the  rendered  text  window.



 \item  \strong{Errors.} Errors  are  immediately  flagged  in  color  and  in  place  in  the  rendered  text.
\end{itemize}

The  compiler  is  written  in   \href{https://elm-lang.org}{Elm},  a  strictly  typed  language  of  pure  functions.   Elm  is  a  good  language  for  writing  MiniLaTeX  apps  because  (a)  it  is  designed  for  building  web  applications  and  (b)  it  has  an  excellent,  high  performance    \href{https://package.elm-lang.org/packages/elm/parser/latest/}{library  of  parser  combinators} akin  to  Haskell's   \code{parsec}.




 \subheading{Apps}
Below  are  two  links  to   apps  that  use   MiniLaTeX.


\begin{itemize}
\item  \strong{ \href{https://demo.minilatex.app}{Demo.minilatex.app}}:  a  simple  no-signin  app  for  experimenting  with  MiniLaTeX.   Feel  free  to  edit  the  text  you  find  there,  or  clear  it  and  write  something  new.



 \item  \strong{ \href{https://minilatex.lamdera.app/g/34}{Minilatex.lamdera.app/g/34}}:   This  link  takes  you  to  some  class  notes
 hosted  on   \href{https://minilatex.lamdera.app}{minilatex.lamdera.app}.
\end{itemize}

 \href{https://minilatex.lamdera.app}{Minilatex.lamdera.app},  while  still  in  alpha  test,  is  a  full  content-management  system  for  creating,  editing,  and  distributing  MiniLaTeX  documents.


\begin{itemize}
\item  \strong{Guest  access.} Sign  in  to   \href{https://minilatex.lamdera.app}{minilatex.lamdera.app} as   \blue{guest} with  password   \blue{minilatex} to  explore  documents  that  have  been  made  public  by  their  authors.   Both  the  source  and  rendered  text  are  available,  so  you  can  see  how  MiniLaTeX  documents  are  written.



 \item  \strong{Registered  user} Create  and  edit  documents  on  a  dektop  computer  or  tablet.



 \item  \strong{Smart  phone.} Use  in  read-only  mode  on  a  smart  phone.  Students  can  read  class  notes  and  problem  sets  this  way.
\end{itemize}



 \section{Features  of  MiniLaTeX}
Below  is  a  summary  of  MiniLaTeX  features.  See   \href{https://minilatex.lamdera.app/g/21}{the  manual} for  more  details.


\begin{itemize}
\item  \strong{Macros  and  Environments.} Environments  include  theorem,  problem,  definition,  etc.,  as  well  as  equation,  align,  verbatim,  and  more.   The   \code{ \bs{maketitle}},   \code{ \bs{section}},  \code{ \bs{cite}},   \code{ \bs{eqref}} macros  and  many  others  work  as  expected.   Unimplemented  macros  are  rendered  verbatim,  but  colored  red  to  indicate  their  status.



 \item  \strong{Macro  definitions.} One  can  define  both  math-mode  and  text-mode  macros  in  MiniLaTeX.



 \item  \strong{Export.} MiniLaTeX  documents  can  be  exported  to  standard  LaTeX,  complete  with  the  necessary   \code{ \bs{usepackage}} statements,   \code{ \bs{begin}\texarg{document}},   \code{ \bs{end}\texarg{document}},  and  any  needed  macro  definitions.   Exported  documents  are  ready  to  process  with   \code{ \bs{pdflatex}}.   Here  is   \href{https://noteimages.s3.amazonaws.com/anharmonic_oscillator.pdf}{an  example} of  an  exported  document  compiled  to  PDF  using  TeXShop.




 \item  \strong{Images.} The  macro   \code{ \bs{image}\texarg{URL}\texarg{Caption}\texarg{Format}} is  used  to  place  images  in  a  MiniLaTeX  document.
 Provision  is  made  to  render  images  in  exported  documents.   There  is,  in  addition,  an   \code{svg} environment  for  rendering  SVG  images  from  SVG  source  code.



 \item  \strong{Unicode.} MiniLaTeX  accepts  unicode  (UTF-8)  input.  More  needs  to  be  done  to  accomodate  unicode  in  exported  documents.



 \item  \strong{Paragraph-centric.} MiniLaTeX  is   \blue{paragraph-centric},  meaning  that  the  smallest  unit  of  recompilation  is  the   \italic{logical  paragraph}.   A  logical  paragraph  is  either  an  ordinary  paragraph  or  an  outer  begin-end  block delimited above and below by a blank line.



 \item  \strong{Additions.} Besides  the   \code{ \bs{image}} command,  there  are  various  other  commands  that  exist  in  MiniLaTeX  but  not  plain  LaTeX.   These  commands  are  provided  with  suitable  macro  definitions  on  export  so  that  a  MiniLaTeX  document  can  always  be  compiled  with  standard  LaTeX  tools.   Here  are  some  examples.   Text  can  be  colored  blue  using  the   \code{ \bs{blue}} macro:   \italic{I  am  feeling   \blue{blue}}.   Text  can  be  highlighted  using  the   \code{ \bs{highlight}} macro.   The  teacher  said  that   \highlight{all  work  on  our  class  project  is  due  by  October  1}.
 There  is  also  a   \code{ \bs{strike}} macro:  Please  delete  this   \strike{very  bad  word}.   For  a  complete  list  of  additions,  see   \href{https://minilatex.lamdera.app/g/21}{minilatex.lamdera.app/g/21}.
\end{itemize}

An  important  part  of  the  MiniLaTeX  project  is  to  properly  define  the  subset  of  LaTeX  to  be  supported.   The  current  rule  of  thumb  for  this  is  "good  enough  to  write  my  lecture  notes,  class  hand-outs,  and  problem  sets."   Feedback  on  this  issue  is  much  appreciated  (jxxcarlson  at  gmail).



 \section{Some  features  of  minilatex.lamdera.app}
The  content  management  system   \href{https://minilatex.lamdera.app}{minilatex.lamdera.app} provides  a  system  for  creating,  editing,  and  distributuing  documents  from  a  searchable  repository.   Users  can  search  by  title,  author,  etc.   Documents  can  be  collaboratively  edited,  shared  by  URL,  and  versioned  on  Github  through  a  simple  user  interface.   Documents  can  also  be  exported  to  PDF.


In  addition  to  the  familiar   \code{ \bs{href}} macro,  there  are   \code{ \bs{xlink}} and   \code{ \bs{ilink}}.   The   \code{ \bs{xlink}} macro
 is  used  to  make  a  link  from  one  document  to  another  in   \code{minilatex.lambdera.app}.    Thus,  one  can  say
  \code{ \bs{xlink}\texarg{21}\texarg{Manual}} to  make  a  link  to  document 21 with label \italic{Manual}.


The   \code{ \bs{ilink}} macro  is  similar.   It  has  the  same  syntax,  but  is  used  in  constructing  a  page  of  links  which  functions  as  a  table  of  contents  or   \italic{index  document} for  a  master  document,  aka  a  book.   For  an  example,  see   \href{https://minilatex.lamdera.app/g/34}{these  class  notes}.  It  is  worthwhile  looking  at  the  source  to  see  how  it  is  done.


 \section{The  MiniLaTeX  Compiler}
The  MiniLaTeX  compiler  consists  of  two  parts,  a   \italic{parser} and  a   \italic{renderer}.   The  first  is  a  function


$$
parse: \text{Source text} \to \text{AST},
$$

where   \italic{AST} stands  for   \italic{Abstract  Syntax  Tree}.   This  is  a  tree  with  nodes  like


\begin{verbatim}
LXString "Pythagoras says"
\end{verbatim}

and


\begin{verbatim}
InlineMath "a^2 + b^2 = c^2"
\end{verbatim}

that  expresses  a  grammatical  analysis  of  the  source  text,  identifying  its  "parts  of  speech"  and  putting  them  in  relationship  to  one  another.
 The  second  is  a  function


$$
render: \text{AST} \to \text{HTML}
$$

The  compiler  is  the  composite  of  these  two  functions:


$$
compile   = render \circ parse
$$

The  strategy  that  makes  writing  such  a  compiler  feasible  is   \italic{divide  and  conquer}.   One  writes  the  parser  using  parser  combinators.   One  then  constructs  function  which  renders  the  text-mode  LaTeX  to  HTML,  passing  the  math-mode  text  on  to  either   \href{https://mathjax.org}{MathJax} or   \href{https://katex.org}{KaTeX} for  rendering.


 \strong{Video}:   \href{https://www.youtube.com/watch?v=dmDA7iziSgs&t=15s}{Making  a  LaTeX-to-Html  parser  in  Elm}

 \subsection{AST}
Every  value  in  a  statically  typed  language  like  Haskell,  ML,  or  Elm,  has  a   \italic{type}.   Below  is  the  type  of  the AST  for  the  MiniLaTeX  compiler.   Writing  down  this  type  definition  was  the  first  step  in  writing  the  parser.


\begin{verbatim}
 1 type LatexExpr
 2     = LXString String
 3     | Comment String
 4     | Item Int LatexExpression
 5     | InlineMath String
 6     | DisplayMath String
 7     | SMacro String (List LatexExpr) (List LatexExpr) LatexExpr
 8     | Macro String (List LatexExpr) (List LatexExpr)
 9     | Environment String (List LatexExpr) LatexExpr
10     | LatexList (List LatexExpr)
11     | NewCommand String Int LatexExpr
12     | LXError (List (DeadEnd Context Problem))
\end{verbatim}
Note  that  the  definition  of   \code{LatexExpr} refers  to  itself,  hence  is  recursive.   This  is  typical  of  the  definitions  of  types  of  structured  trees.
 To  give  an  idea  of  how  the  parser  works,  consider  the  following   examples.  In each, the first
 line is source text, the second is the resulting AST.


\begin{verbatim}
> Pythagoras
LXString "Pythagoras"

> \strong{Pythagoras}
Macro "strong" [] [LatexList [LXString "Pythagoras"]]

> \strong{Pythagoras} says that $a^2 + b^2 = c^2$
Macro "strong" [] [LatexList [LXString "Pythagoras"]]
  , LXString "says  that "
  , InlineMath "a^2 + b^2 = c^2"
\end{verbatim}

The  parser  takes  up  roughly  500  lines  of  Elm  code  and  consists  of  a  set  of  functions  which  call  upon  one  another.   The  top-level  parser  function  is  given  below.   Note  the  close  correspondence  between  its  parts  and  the  parts  of  the  type  definition.   It  is  built  using     \code{oneOf},  a  combinator  which  takes  a  list  of  parsers  as  arguments  and  which  returns  a  parser  as  value.



\begin{verbatim}
 1 latexExpression : LXParser LatexExpr
 2 latexExpression =
 3     oneOf
 4         [ texComment
 5         , displayMathDollar
 6         , displayMathBrackets
 7         , inlineMath
 8         , newcommand
 9         , macro
10         , smacro
11         , words
12         , lazy (\_ -> environment)
13         ]
\end{verbatim}
We  give  one  more  example,  the   \code{macro} parser.   It  uses  the  combinators   \code{(|=)} and   \code{(|.)} to   \italic{sequence} parsers  and  thereby  to  form  a  new  parser.   The  resulting  "parser  pipeline"  operates   in  the  following  way.    First,  find  the  name  of  the  macro,  then  the  list  of  optional  arguments,  then  the  list  of   actual  arguments,  then  eat  any  whitespace  (spaces,  newlines).   Second,  feed  the  values  found  in  the  order  found  to  the  constructor   \code{Macro} for  the   \code{LatexExpr} type.

In  this  example,   \code{whitespace} is  a  parser  for  white  space,  which  can  come  in  different  flavors  depending  on  context  e.g.,  spaces  only  or  spaces  and  newlines.


\begin{verbatim}
 1 macro : LXParser () -> LXParser LatexExpr
 2 macro =
 3     succeed Macro
 4         |= macroName
 5         |= itemList optionalArg
 6         |= itemList arg
 7         |. whitespace
\end{verbatim}
One  can  continue  down  the  rabbit  hole,  explaining  the  parsers    \code{macroName},   \code{optionalArg},    \code{arg} and  the  combinators   \code{itemList},  etc,  but  we  stop  here.   What  is  important  to  understand  is  that  there  are  really  only  three  things  in  something  like  the  MiniLaTeX  parser:  primitive  parsers,  combinators  that  choose  among  alternatives,  and  combinators  that  sequence  other  parsers.  As  a  note,  eating trailing  whitespace  is important because  in the present setup,  lexing  and  parsing  are  not  separate  operations.


 \subsection{Rendering}
The  top-level  rendering  function  is  much  like  the  top-level  parsing  function.  It  analyzes  the  type  of  a  LatexExpr  and  dispatches  the  appropriate renderer,  which  may  in  turn  call  other  rendering  functions,  including  the  top  level  one.  And  so  on,  down  the  rabbit  hole  of  function  calls  we  go.


 \subsection{Code}
Code  for  the  MiniLaTeX  compiler  as  well  as  the  demo  app  is  found  at   \href{https://github.com/jxxcarlson/meenylatex}{github.com/jxxcarlson/meenylatex}.   The  strange  name  is  to  reserve  the  name   \blue{github.com/jxxcarlson/minilatex} for  a  future  stable  version  with  a  polished  API.

The  code  for  the   \href{https://minilatex.lamdera.app}{minilatex.lamdera.app} is  at   \href{https://github.com/jxxcarlson/lamdera-minilatex-app}{github.com/jxxcarlson/lamdera-minilatex-app}.
All  code  is  open  source.


 \section{Feedback}
I  am  very  interested  in  feedback  from  the  community  regarding  features,  bugs,  etc.   Of  special  interest  is  the  subset  of  LaTeX  used:  what  should  it  be?
Comments  to  jxxcarlson  at  gmail.


 \section{Acknowledgements}
I  would  like  to  thank  Evan  Czaplicki,  Ilias  Van  Peer,  Mario  Rogic,  and  Luke  Westby,  all  of  the  Elm  community,  Davide  Cervone,   \href{https://mathjax.org}{MathJax.org},  and  the  team  at   \href{https://katex.org}{Katex.org} for  their  generous  and  invaluable  help.    I  also  wish  to  thank  the   \href{https://simonsfoundation.org}{Simons  Foundation} for  its  support  of  this  project.


 \italic{This  document  was  written  in  MiniLaTeX  and  is  avaiable  at   \href{https://minilatex.lamdera.app/g/22}{minilatex.lamdera.app/g/22}.}


\end{document}
