beginMetadata:
{
    "id": "da627069-1668-4999-9c6c-19f14a632e29",
    "documentNumber": 286,
    "author": "jxxcarlson",
    "title": "Agda",
    "path": "nott/agda.tex",
    "tags": [],
    "keyString": "agda a=jxxcarlson nott/agda.tex ",
    "timeCreated": 1604284514165,
    "timeModified": 1611966040006,
    "public": true,
    "collaborators": [],
    "docType": "miniLaTeX",
    "versionNumber": 4,
    "versionDate": 1611947484544
}
endMetadata
\include{type-macros-jxxcarlson}

\xlink{uuid:defbbdbb-d45d-46d1-96b0-371a7048ba41}{Notes on Type Theory}

\setcounter{section}{3}

\section{Agda}

\innertableofcontents


\italic{WIP: More focused on Agda than type theory per se in this section.}

Below we collect some information on running Agda, e.g., emacs commands, as well as some examples.  All this is explained carefully in PLFA.

\subsection{Command summary}

\begin{colored}[bash]
C-c C-l: Load and type-check the file
C-c C-n expr: normalize expr

C-c C-c x: case split on variable x
C-c C-f move into the next hole.
C-c C-space: fill in hole
C-c C-r: refine with constructor
C-c C-a: automatically fill in hole
C-c C-,: goal type and context
C-c C-.: goal type, context, and inferred type
\end{colored}


\subsection{Example: the Natural Numbers}

The type of natural numbers is defined in the code below.  We put it in a file \code{nat.agda}.

\begin{colored}[elm]
data ℕ : Set where
    zero : ℕ
    suc  : ℕ → ℕ
  
{-# BUILTIN NATURAL ℕ #-}
\end{colored}

The first line corresponds to the formation rule: it announces the fact that \ccode{ℕ} is a type in the universe \ccode{Set.} The next two lines correspond to the introduction rules.  They announce the constructors.
The last line, in effect, sets up the definitions \colored{elm}{0 = zero,} \colored{elm}{1 = suc 0,} \colored{elm}{2 = suc (suc zero),} etc.  

In Emacs, type \code{C-c C-l} to load and type-check the file. Type \code{C-c C-n}, then \ccode{suc (suc 0)} to evaluate (normalize or simplify) the latter expression.  Did you get what you expected? Now add the code below.  It gives an inductive defnition of a function which adds to numbers together:

\begin{colored}[elm]
add : ℕ → ℕ → ℕ
add zero m = m
add (suc m) n = suc (add m n)
\end{colored}


Type \code{C-c C-l} to type check, then \code{C-c C-n} and \ccode{add 1 2} followed by  \ccode{add 1 2}.  The expression evaluates to \ccode{3}  Finally, add the code

\begin{colored}[elm]
_+_ : ℕ → ℕ → ℕ
_+_ zero m = m
_+_ (suc m) n = suc (add m n)
\end{colored}

Here \code{_+_} is an \term{infix operator}, so we can say \code{C-c C-n}, then \ccode{1 + 2} to obtain \ccode{3} as before.


\subsection{Binary representation of numbers}

The type \colored{elm}{Bin} given below defines a binary representation of the natural numbers.  In it, 5 is represented as \code{((<> I) O) I}, which we think of as 101.  The definition is somewhat similar to the definition of $\bbN$.  The term \ccode{<>} plays the role of zero.  The postfix operator \ccode{_O} is the binary operator "shift left."  The postfix operator \ccode{_I} is the binary operator "shift left, than add 1." 

\begin{colored}[elm]
data Bin : Set where
  <> : Bin
  _O : Bin → Bin
  _I : Bin → Bin
\end{colored}

Using pattern-matching and recursion, we define \ccode{inc}, the operator which increases the value of a binary number by 1.  There is one base case and \italic{two} recursive clauses.

\begin{colored}[elm]
inc : Bin → Bin
inc <> = <> I          -- base case
inc (x O) = x I        -- recursion, A
inc (x I) = (inc x) O  -- recursion, B
\end{colored}


\subsubsection{Conversion}

If we have two ways of representing natural numbers — unary and binary — we shoud have a way of converting from one to another.  That is what \ccode{to : ℕ → Bin} and 
\ccode{from : Bin → ℕ} do.

\begin{colored}[elm]
to : ℕ → Bin
to 0 = <> O
to (suc n) = inc (to n)

from : Bin → ℕ
from <> = 0
from (x O) = double (from x)
from (x I) = suc (double  (from x))
\end{colored}

We expect that if we conver from \ccode{ ℕ } to \ccode{Bin} and back that obtain what we started with.  This expectation can be formulated as a type, that is, as a proposition:

\begin{colored}[elm]
id-from-to : ∀ (n : ℕ) → from(to n) ≡ n
\end{colored}

To prove this proposition is to construct an inhabitant.  Once we do so, we can stat that \ccode{from} is a \term{left-inverse} for \ccode{to.}. We also expect that it be a right inverse:

\begin{colored}[elm]
id-to-from : ∀ (b : Bin) → to(from b) ≡ b
\end{colored}


\subsubsection{Tests}

Before proving the preceding propositions, we test to see if they hold.  Thus, we compute \ccode{from(to 5)}, which has value 5.  This is reassuring. Better would be to apply the function  \ccode{λ x → (from (to x))} to a list of numbers.  To do this, we begin by defining the type of lists:

\begin{colored}[elm]
data List (A : Set) : Set where
  []  : List A
  _∷_ : A → List A → List A

infixr 5 _∷_
\end{colored}

Here \ccode{[]} is the empty list, and \ccode{a::list}  tacks the element \ccode{a} onto the head of list \ccode{list.}  To write \ccode{::} in emacs, we write \code{\bs{::}} so as to get a single unicode synbol.  The next task is to craft a function \ccode{range} for creating lists of consecutive numbers.  Our aim is to be able to say \ccode{range 2} to produce the list \ccode{2 :: 1 :: 0 :: [].} The code for this is, once agiain, an exercise in pattern-matching and recursion:

\begin{colored}[elm]
range : ℕ → List ℕ
range 0 = 0 ∷ []
range (suc n) = (suc n) ∷ range n
\end{colored}

Finally, as in all functional languages, we want a function \ccode{map} that applies a given function of type \ccode{A → A} to the elements of a list of type \ccode{A}.  Then we can say \ccode{map inc (range 2)} to obtain \ccode{ 3 :: 2 :: 1 :: []. }. Here is the code for \ccode{map:}


\begin{colored}[elm]
map : ∀ {A : Set} → (A → A) → List A → List A
map f [] = []
map f (x ∷ xs) = (f x) ∷ map f xs
\end{colored}

With all this in hand, our test is easy to write.  Note the use of lambda.  It gives a way of converting an expression into a function:

\begin{colored}[elm]
map (λ x → (from (to x))) (range 10)
-- produces the below
10 ∷ 9 ∷ 8 ∷ 7 ∷ 6 ∷ 5 ∷ 4 ∷ 3 ∷ 2 ∷ 1 ∷ 0 ∷ []
\end{colored}

\subsubsection{Proofs}

We now set about showing that the type \ccode{id-from-to} is inhabited.  This we do by constructing, via induction, a function of that type.  In the base case of \ccode{n = 0}, the type is

\begin{colored}[elm]
id-from-to 0 = from(to 0) ≡ 0
\end{colored}

The left-and side reduces as follows

\begin{colored}[elm]
from(to 0)
from(<> O)
double(from <>)
double 0
0
\end{colored}

Thus the type \colored{elm}{from(to 0) ≡ 0} is the same as the type \colored{elm}{0 ≡ 0}.  Consequently it is inhabited by \colored{elm}{refl.} In the inductive case, the type is

\begin{colored}[elm]
id-from-to (suc n) = from(to (suc n)) ≡ suc n
\end{colored}

We claim that the following transformations of the left-hand side are possible, each obtained by rewriting rules, which we will explain momentarily:

\begin{colored}[elm]
from(to (suc n))
from(inc(to n))  -- le-to-suc: to suc => inc to
suc(from(to n))  -- le-from-inc-to: from inc => suc from
\end{colored}

If this is so, then \colored{elm}{from(to (suc n)) ≡ suc n} is the same type as \colored{elm}{suc(from(to n) ≡ suc n}.  Recall the congruence principle from the previous section:

\begin{indent}
If $e : x \equiv y$ then $cong\ f\ e: f\ x \equiv f\ y$
\end{indent}

The principle asserts the existence of a function \ccode{cong} that maps terms of type  \ccode{x ≡ y} to terms of type \ccode{f x ≡ f y}.   That is, if the type \ccode{x ≡ y}  is inhabited by some term \ccode{e}, then the type \ccode{f x ≡ f y} is inhabited by a term \ccode{cong f e}
By induction, we suppose that \ccode{from(to n) ≡ n} is inhabited.  By the congruence principle, we conclude that \ccode{suc(from(to n))  ≡ suc n} is in inhabited.

This concludes the proof, modulo a proof of the lemmas \ccode{le-to-suc} and \ccode{le-from-inc-to} that justify the transformations above.


\subsubsection{Elementary lemmas}

The first step is to observe that we have a set of elementary lemmas that follow immediately from the definitions.  

\begin{colored}[elm]
le-double : ∀ (n : ℕ) → double(suc n) ≡ suc(suc(double n))
le-to-suc : ∀ (n : ℕ) → to(suc n) ≡ inc(to n)
le-from-shift : ∀ (b : Bin) → from (b O) ≡ double (from b)
le-from-shift2 : ∀ (b : Bin) → from (b I) ≡ suc (double (from b))
\end{colored}

As an example, we prove the third lemma:

\begin{colored}[elm]
le-from-shift : ∀ (b : Bin) → from (b O) ≡ double (from b)
le-from-shift <> = refl
le-from-shift (b O) = refl
le-from-shift (b I) = refl
\end{colored}

Since all clauses are proved in the same way, we consider only the third, the function \ccode{le-from-shift,} applied  to \ccode{b O}. This function value is the type

\begin{colored}[elm]
from ((b O) O) ≡ double(from (b O))
\end{colored}

By the defining equations for \ccode{from,} we have

\begin{colored}[elm]
from ((b O) O) ≡ double(from (b O))
\end{colored}

Therefore the type in question is the same as the type

\begin{colored}[elm]
double(from (b O)) ≡ double(from (b O))
\end{colored}

This type is inhabited by \ccode{refl,}  and so we are done.

\subsubsection{Lemmas with rewrite}

For the proof of the main proposition, two lemmas are required, \ccode{le-to-suc} and \ccode{le-from-inc-to.} The first of these is proved. For the second, we first show the following:

\begin{colored}[elm]
le-from-inc : ∀ ( b : Bin ) → from(inc b) ≡ suc(from b)
\end{colored}


\subheading{Base case}
The base case is \ccode{from(inc <>) ≡ suc(from <>).} Applying the rules for \ccode{inc} and \ccode{from}, one transforms this type to an equal type \ccode{suc 0 ≡ suc 0.} Therefore the type \ccode{le-from-inc <>} is inhabited by \ccode{refl.}

\subheading{First inductive case}

The type in question is

\begin{colored}[elm]
le-from-inc (b O) = from(inc(b O))  ≡ suc(from (b O))
\end{colored}

The left-hand side is definitionally equal to \ccode{suc(double(from b)),} so

\begin{colored}[elm]
le-from-inc (b O) = suc(double(from b)) ≡ suc(from (b O))
\end{colored}

The lemma \ccode{le-from-shift} tells us that the type 



\subsection{Using rewrite}


Another way to do the inductive proof is to use \term{rewrite}.  To explain, consider this step in the proof of the associative law:

$$
 suc ((m + n) + p) \equiv suc (m + (n + p))
$$

 If we rewrite the left-hand side using the inductive hypothesis, this becomes

\begin{equation}
suc (m + (n + p) \equiv suc (m + (n + p))
\end{equation}

In this expression, the left and right-hand sides are equal, and so a proof is given by $\refl$. 
The full sequence of simplifications need for the proof then go as follows: (a) simplify the left and right sides of the equality type using the rules for addition (b) rewrite the left-hand side of resulting expression using \code{rewrite} for the inductive hypothesis. We can encode this sequence of operations in the last line of the proof as presented below.  

\begin{align}
& \text{+-assoc}' : ∀ (m\ n\ p\ : ℕ) → (m + n) + p ≡ m + (n + p) \\
& \text{+-assoc}'\ zero\ n\ p = \refl \\
&\text{+-assoc}' (suc\ m)\ n\ p\space \text{rewrite}\space \text{+-assoc}'\  m\ n\ p = \refl 
\end{align}

Note that congruence and rewrite, while achieving the same ends, operate in different ways.   Congruence tells us that if we have evidence for $e \equiv e'$, then we also have evidence for $suc\ e \equiv suc\ e'$.  Rewrite tells us that $suc\ e \equiv suc\ e'$ reduces to $suc\ e' \equiv suc\ e'$, provided that we know (by the inductive hypothesis) that $e \equiv e'$.  Finally, $suc\ e' \equiv suc\ e'$ is inhabited by $\refl$.
